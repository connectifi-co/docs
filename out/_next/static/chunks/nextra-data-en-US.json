{"/Actions/data-api":{"title":"Data API","data":{"":"Connect to REST APIs for event-driven data requests between apps.The Data API action, allows you to add your applications API's to initiate action within your application. This could enable triggering an automated process such as sending a message, or much more.\nData API URL: The URL of the web service API that returns context data.\nTimeout: Specify how long your webhook will wait for a response before timing out."}},"/Actions/Actions":{"title":"Actions","data":{"":"An action an event that is triggered by a user, examples include sharing data with a CRM, receiving inlign data, sending an email, updating a spreadsheet, or posting a message.Actions equip your applications to begin a workflow either in-app, or to another application. There are three types of actions:\nData API: Connect to REST APIs for event-driven data requests between apps.\nDeeplink: Deep links are a type of link that send users directly to an app, with given context. The use of (custom) URL schemes to direct users to specific pages within an app, enhancing user engagement, retention, and improving conversion rates.\nEnhanced Deeplinks: Allows you to connect to custom functions to generate deep links.","create-an-action#Create an Action":"When creating an application, you can add Actions. Click on the top-right of the screen to 'Add Action'. You can add as many actions as you would like. Additionally you can have different types of actions, so even if you only need a deep link action at first, you can later advance to using an advanced deeplink action."}},"/Contexts":{"title":"Contexts","data":{"":"Contexts are the pieces of data/content that can be used by intents and applications. Contexts define types of data to be transferred between applications. Contexts can be shared directly by broadcast or paired with Intents to perform a specific action such as launching or triggering a specific function of an application or retrieving data from a remote service. Contexts can be viewed as having two types:\nOutput contexts control active contexts. When an intent is matched, any configured output contexts for that intent become active.\nInput contexts control intent matching.","adding-contexts#Adding Contexts":"Additionally, you can use the “Create Context” button to create custom contexts for the directory. To create a custom context:\nNavigate to the “Contexts” page, from the left-hand navigation. Here you'll be able to see all provided default contexts.\nClick onto Create Context on the top-right hand corner to begin creating an context.\nContext Type: Enter a name for the context. Please note that Context Type needs to be unique, as you will need to reference these within your code.\nDescription: This is a Full description of this context data structure and its use.\nClick the “Create” button to create the context."}},"/Actions/enhanced-deep-links":{"title":"Enhanced Deep Link","data":{"":"Connect to custom functions to generate deep links."}},"/Channels":{"title":"Channels","data":{"":"Channels provide apps isolated environments to display their data by having the apps join them. A lot can be done with channels in FDC3; below are a few basic concepts to get started.App channels are very useful when it comes to more advanced orchestration of behavior between applications, especially when there is a singleton or platform application orchestrating a number of child or satellite applications. Some use cases may include:\nTracking the state of a singleton application across multiple tech stacks\nPublishing application data shared outside of intents or other user actions\nSynchronizing a user state for a session across multiple applications and tech stacks","custom-channels#Custom Channels":"By default, the Connectifi agents has 6 channels available; however, we do allow for the creation of custom channels. Custom Channels are defined at the directory level:\n\nTo create custom channels:\nNavigate to your directory and edit it.\nCheck the \"Use Custom Channels\" box.\nClick the \"+\" button to add a channel.\nEnter the relevant information for the channel.\nSelect a color for the channel. When selecting a color, you can select one from the color picker or use the eye dropper tool to select a color that exists on your screen; you also have the option of entering RGB/HSL/Hexcode values by clicking the Up/Down button:\n\n\n\n\nAdd as many channels as you need, and then click the \"UPDATE\" button to submit your updates to the directory.\n\nPlease note that when using custom channels, the default channels are not included in the agent.","joiningchannels#joiningChannels":"As mentioned previously, apps can be joined to a user channel (referred to as system channel in FDC3 1.x) by the end user. This links any apps on a channel so that a call to fdc3.broadcast is routed to context listeners (set via fdc.addContextListener) from any other app on the same channel.Please note that an app can only be joined to one channel at a time.Apps can be joined to a channel using either the UI or programmatically. In the UI, you can specify which channel the app is joining by clicking on the Connectifi FAB that appears on screen and then selecting the desired channel:If you're doing it programmatically, the code would look something like this:\nawait fdc3.joinUserChannel('red');\nconsole.log('red channel joined!');\n\n// Exiting the channel\nfdc3.leaveCurrentChannel();","joining-vs-subscribing-to-a-channel#Joining vs Subscribing to a Channel":"Joining a channel, as noted above, impacts the scope of the fdc3.broadcast and fdc3.addContextListener calls. An app can also explicitly get a reference to a channel and broadcast and/or add listeners to it (subscribing). Some key differences between joining and explicitly attaching to channels are:Joining a channel can be done by the end user via the UI of the FDC3 provider (e.g. the Connectifi agent UI).\nOnly one channel can be joined at a time, whereas any number of channels can be subscribed to programmatically.When a channel is joined, it will automatically receive the current context for the channel. When subscribing to a channel programmatically, the current context needs to be acquired manually.","getting-a-channel#Getting a Channel":"The getOrCreateChannel function provides a reference to a channel object that can be used to broadcast, assign listeners, and query for context state. For example:\n//programmatically subscribe the 'red' system channel\nconst redChannel = await fdc3.getOrCreateChannel('red');\n\nconst listener = redChannel.addContextListener('fdc3.instrument', (context) => {\n/* listener logic */\n});\n\n//get the latest context on the channel\nconst currentContext = await redChannel.getCurrentContext('fdc3.instrument');\n\n//broadcast a context on the channel\nredChannel.broadcast(myContext);\n\n//get or create an 'app' channel\nconst myChannel = await fdc3.getOrCreateChannel('myChannel');\nPlease note the getOrCreateChannel function can used to either get a user/system channel, or to get or create an app channel. App channels are defined by an application, as opposed to being defined and controlled by the FDC3 provider. Since Connectifi directories can restrict what apps have access to interop in a specific directory, as well as verify the identity of apps connecting into the directory, app channels can have a much higher security profile than on a desktop bus."}},"/Actions/deep-link":{"title":"Deep link","data":{"":"Launch apps using contextually driven deep links.Deep links are templated urls which can use the current intent/context to link into an application. To use, simply encapsulate context properties inside double curly braces. Using the StartChat intent (or any intent that understands the context fdc3.contact), the contact email address can be referenced in the url template like so:\nhttps://messenger.com?user={{id.email}}\nSimilarly for ViewQuote or ViewInstrument and the fdc3.instrument context:\nhttps://finance.com/quote?symbol={{id.ticker}}"}},"/Directories":{"title":"Directories","data":{"":"Directories help you segment and separate your applications. In many ways, they reflect folder systems, where user groups may have permission to a certain set of applications. Here we use directories for the following reasons:\nRestrict application communication: Ensure applications can communicate to one another, securely. This prevents external apps from communicating to authorised applications when they shouldn't.\nTeam specific applications: Teams can use widely different applications. This enables you to create groups of applications refective of internal team usage.\nDevelopment Environments: Folders can reflect development environments, such as development, staging, testing or prod.","creating-directories#Creating Directories":"With Connectifi, applications interop by connecting to the same directory. The directory determines what applications can participate and defines the security parameters. Applications, contexts, and intents are all defined within a directory. To create a directory:\nSign into the Connectifi admin UI. If you have your own instance of Connectifi, a custom URL is created for your environment account_name.connectifi-interop.com\nClick on the 'Directories' in the Left hand nav. Here you will be presented with a grid or list view of all of your directories.\nClick on 'Create Directory', in order to create a new directory.\nBegin filling in the name and description of the directory to determine the objective of the directory.\nAdd your directories logo. We recommend a 256x256 png.\n\n\n\n\nThe “Interop Strategy” setting determines the security and access model for the directory\nOpen: Any applications can connect to the directory\nOpen+Auth: Any application can connect to the directory, but the user needs to be logged into Connectifi to connect to the directory.\nApp: Only applications registered in the directory can connect to the directory\nStrict: Users must be logged into added applications and said applications must be registered in the directory in order to connect to the directory\n\n\n\n\n\n\nThe “Allow Instance Discovery” option restricts how much data applications can access via the FDC3 API\nBroadcasting, provides a default communication bus, where if an application sends a message it will send it to all other applications. This is simplier, than having channels, which provides you the ability for apps to be grouped onto the same communication channel.\nThe “Deliver Hook” setting allows you to specify an endpoint that can ingest data sent from broadcast or intents in the directory. For more details on this, feel free to check out our article on delivery hooks found here.\nClick the 'Create' button at the bottom of the page to complete creating your directory.","edit-directories#Edit Directories":"From the directories level: Click on the actions on the directory card. Select 'Edit' to begin editing or 'Settings' to view all of the settings.\n\n\n\n\nFrom view directory: Click on the upper right 'Edit Settings' button.\nDon't forget to click 'Update' when you've completed yoru changes. Your changes will take immediate affect.","connecting-to-a-directory#Connecting to a Directory":"With Connectifi, applications participate in interop by connecting to the same directory. The directory determines what applications can participate and what the security parameters will be.To connect to a directory, use the createAgent function exported from the agent-web module, and pass in the service URL and the identity of your application. This will return a Promise resolving to a standard FDC3 API.\nimport { createAgent } from '@connectifi/agent-web';\n\nconst fdc3 = await createAgent(\n`https://[ME].connectifi-interop.com`,\n`$[appName]@$[directoryName]`,\n);\nNote: Because the FDC3 API is returned as a scoped variable, your application can leverage any number of approaches to FDC3. For example, the API can be used in module scope - allowing for multiple connections on a page, or it can be declared as a global - providing backwards compatibility with desktop container patterns. Also, the connection to the service can be multiplexed to allow for multiple FDC3 'apps' in a single page. For an example of multiplexing, see this open source repo."}},"/Receptors/Multibroadcast":{"title":"Multi Broadcast","data":{"":"This scenario allows you to broadcast contexts to specific recipients. This allows you to inform and update specific users. Example use cases include:\nPersonalized notifications that are specific to a user, such as a completed transaction, action or workflow\nAnnouncements to a team of individuals\nResponse from an AI LLM Chatbot, specifically for the individuals needs"}},"/Receptors/Broadcast":{"title":"Broadcast","data":{"":"This scenario allows you to join a channel and broadcast contexts to other apps, on behalf of a user.\nFrom header is the email of who you want to perform the broadcast on behalf of.\nAllowed Channels: The list of channels this receptor is allowed to broadcast, an empty list implies all channels","notes#Notes":"Broadcasting must be targeted at specific user sessions; the user's email address specifies the session.\nYou can use the picker to join a color-coded System/User channel and then use the grid to broadcast an instrument context or the 'Advanced' option to broadcast any type of context. You can see the resulting channel context using the 'Channel Viewer' or load an app that receives context in the right panel (for example, a chart or news app)."}},"/Receptors/Receptors":{"title":"Receptors","data":{"":"Receptors define incoming data endpoints allowing services to push context data to end-users. A Receptor exposes a web hook URL that can be called by outside services to push messages to users on behalf of the app. Receptor hooks can be used for a wide range of use cases such as:\nPush in-app alerts to users from backend services\nIntegrations between FDC3 applications and back-end services and non-FDC3 applications such as CLIs and macros\nSharing context objects between users.\n\nReceptors equip your applications to:\nBroadcast: This scenario allows you to join a channel and broadcast contexts to other apps, on behalf of a user.\nMulti Broadcast:\nRaise an Intent: This scenario lets you set up intent handlers. Use the form to select an intent to listen for. You can test the listener against a demo app or your app using the panel on the right.","creating-a-receptor#Creating a Receptor":"When creating an application, you can add Receptors. Click on the top-right of the screen to 'Add Receptor'. You can add as"}},"/Intents":{"title":"Intents","data":{"":"Intents are predefined nouns that applications can perform. Use app intents to express your app's capabilities to the system. An app intent includes the code you need to perform an action, and expresses the data you require from the system. App Intents allow you to expose the things your app does to both the system and other applications.Intents can be used to launch an activity, start the services, broadcast receivers, display a web page, dial a phone call, send messages from one activity to another activity, and so on.Intents are used for navigating among various activities within the same application, but they are not limited to one single application, i.e., they can be utilized from moving from one application to another as well.\n\nThere are two types of intents:\nExplicit intents specify which component of which application will satisfy the intent. You'll typically use an explicit intent to start a component in your own app, because you know the class name of the activity or service you want to start. For example, you might start a new activity such as running a generative AI to summarize data within your app in response to a user action, or start a service to download a file in the background.\nImplicit intents do not name a specific component, but instead declare a general action to perform, which allows a component from another app to handle it. For example, if you want to show the user a location on a map, you can use an implicit intent to request that another app show the location on a map.","adding-intents#Adding Intents":"Intents are created globally in Connectifi, for all directories and their corresponding applications to use. This allows you to create a consistent intent framework. They can be used as much as you would like them to be used.To create a custom intent:\nNavigate to the “Intents” page, from the left-hand navigation. Here you'll be able to see all provided default intents.\nClick onto Create Intent on the top-right hand corner to begin creating an intent.\nIntent Name: Enter a name for the intent. Please note that intent names need to be unique, as you will need to reference these within your code.\nDisplay Name: Enter a display name that your users will see. Again, we recommend this has uniqueness, so your users do not get confused if they are provided UX that uses both intents, as this can be confusing.\nDescription: Describe clearly the purpose of this intent in a complete sentence.\nContexts: Select the contexts the intent can act upon. Please note available contexts are created separately. Applications can choose which specific contexts they will support, from the one's provided with the intent.\nClick the “Create” button to create the intent.","best-practice-for-intents#Best Practice for Intents":"Identify common actions: Focus on creating intents that people are likely to use frequently: such as looking up information, and recording activity.\nTrails: Consider the workflow and trail of your user. for example, if they execute a trade, what will they be likely to do next?\nLimit your Intents initially: Create between three and five intents that are relevant to your business at first. Then expand as needed.","default-intents#Default Intents":"In order to get started quickly with Connectifi, we offer a series of default intents. One example shown below, is 'Generate Summary'. Using this you could have multiple generative applications such as OpenAI, or Anthropic using this, to take in data and provide a summary."}},"/SDK/iOS":{"title":"Agent Setup","data":{"":"This package provides a wrapper around @connectifi/agent-web to provide native swift bindings. In addition, a default resolver UI that can be used in your application.\nInstallation\nSwift Package Manager\nAdd package to your target dependencies in Package.swift:\n\n\nimport PackageDescription\n\nlet package = Package(\nname: \"YourProject\",\ndependencies: [\n.package(\nurl: \"PUT_URL_HERE\",\nfrom: \"PUT_VERSION_HERE\"\n),\n]\n)\nThe exposed class is ConnectifiAgent which implements the FDC3 2.0 API. The constructor takes two arguments with an optional third.\ninteropHost - the URL of the Connectifi service the app is targeting\nappId - the FDC3 appId for the app. Note: this must be in the format of appName@directoryName (see security model in @connectifi/agent-web)\nconfig - See the shape of the config struct below\nTODO: ADD PROPS AND OTHER CONFIG\n\n\npublic typealias ConnectifiEventHandler = (ConnectifiEvent) -> Bool\n\npublic struct AgentConfig {\nvar connectifiEventHandler: ConnectifiEventHandler?\n}\n\nconnectifiEventHandler - is a function that receives a connectifi event, specified below and can return true to overwrite the default behavior. Currently, only onAuthError, handleOpen, and handleIntentResolution. Default Behavior is as follows:\nhandleOpen - Opens the url of the app in safari\nonAuthError - Will open the webview to prompt the user to login\nhandleIntentResolution - Will open the resolver UI if either of the connectifi sheets are mounted in the view\n\n\npublic enum ConnectifiEvent {\ncase handleIntentResolution(IntentResolutionRequest)\ncase handleOpen(ConnectifiOpenMessage)\ncase onAuthError(directoryName: String)\ncase onAppIdentityError(directoryName: String)\ncase onLoadError\ncase onChannelJoined(channel: String)\ncase onChannelLeft\ncase onConnected\ncase onDisconnected(retryTime: Double?)\ncase onWorkingChanged(working: Bool)\ncase onSignedIn(username: String)\ncase onSignedOut\ncase onFDC3Ready\n}","handleintentresolution#handleIntentResolution":"This event is emitted when an ambiguous list of intent results is pushed to the app for the end user to resolve. The IntentResolutionRequest struct has two methods:resolveCallback(selected:ConnectifiApp, intent: String) - Select the app with the given intent.\ncloseCallback() - Cancels the intent resolution request. The original \"raise\" call is resolved with an IntentResolution of the current app","view-setup#View Setup":"This package exports ConnectifiContextView. This is used to mount an invisible webview inside your app to prevent it from automatically being killed. As such please mount it near the root of your application. This view also takes the internal view model of the ConnectifiAgent as an argument.Example Usage:\n@main\nstruct MyApp: App {\n\n// This is a wrapper around ConnectifiAgent\n@StateObject var connectifiVM = ConnectifiViewModel()\n\nvar body: some Scene {\nWindowGroup {\nNavigationStack {\nConnectifiContextView(internalVM: connectifiVM.connectifiAgent.internalVM){\nMainView()\n}\n}\n.environmentObject(connectifiVM)\n}\n}\n}\nIn addition, if using the default resolver UI it has to also be mounted inside the application. This package provides the following extension to View.\npublic extension View {\nfunc connectifiDevResolver(internalVMProjected: EnvironmentObject<ConnectifiInternalViewModel>.Wrapper) -> some View {\nreturn self.sheet(item: internalVMProjected.intentResolution, content: {_ in ConnectifiResolverUIView().presentationDetents([.height(500)])})\n}\n\nfunc connectifiShareResolver(internalVMProjected: EnvironmentObject<ConnectifiInternalViewModel>.Wrapper) -> some View {\nreturn self.sheet(item: internalVMProjected.intentResolution, content: {_ in ConnectifiShareView().presentationDetents([.height(200)])})\n}\n}\nTwo default resolver UIs are provided. connectifiDevResolver is most similar to the web resolver ui and provides a list view of all available apps. We recommend this resolver to mostly just be used for an easier debug experience. The connectifiShareResolver provides the users with an experience similar to that of the native iOS share sheet. This resolver UI is more intuitive to use and better aligns to iOS design expectations.Example Usage:\nstruct MainListView: View {\n@EnvironmentObject var connectifiInternalVM: ConnectifiInternalViewModel\n\nvar body: some View {\ntickerListView\n. ///\n.connectifiShareResolver(internalVMProjected: $connectifiInternalVM)\n}\n}"}},"/SDK/Web":{"title":"Resources","data":{"":"Our Web SDK provides a basic implementation of a Connectifi Agent for all web clients including desktop integration platforms, electronjs, and vanilla browsers. It will bind to any Connectifi interop service endpoint and expose a scoped FDC3 api abd more. By default, the Agent will generate UX for standard interop functions such as color picking and intent resolution. It can also be run headless.Install the module in your app:npm i @connectifi/agent-webInclude it in your bundle.\nimport {createAgent} from '@connectifi/agent-web';\nTo bypass bundling, you can also load the Agent from unpkg.com and use directly as a script module:\n<script type=\"module\" >\nimport { createAgent } from \"https://unpkg.com/@connectifi/agent-web/\";\n\ncreateAgent(\n`https://[ME].connectifi-interop.com`,\n`$[appName]@$[directoryName]`,\n)\n.then((fdc3) => {\n// do fdc3 things...\n});\n</script>","usage#Usage":"The module exposes a single function: createAgent which returns a Promise that resolves with a standard FDC3 2.0 API (DesktopAgent) after successfully connecting to the specified interop service. The function takes 3 arguments:\ninteropHost - the URL of the Connectifi service the app is targeting\nappId - the FDC3 appId for the app. Note: this must be in the format of appName@directoryName (see security model below)\n\n\nconfig - optional configuration for the Agent including the following props:\n\n\n\n\nlogger - a callback function for logging output from agent\nheadless - boolean flag to run the Agent in headless mode (it will just make a connection and expose the FDC3 API)\nprops - a collection of properties to configue the UI for the agent\nlogoSrc - override the logo image\n\nNote: If you need an FDC3 1.2 intereface, you can use the 1.3.2 version of this module.","simple-creation-example#Simple creation example":"const fdc3Session = await createAgent('https://dev.connectifi-interop.com, 'myApp@myDirectory');\n\n//then use the standard FDC3 API\nconst listener = await fdc3Session.addContextListener('fdc3.instrument', handleContext);\nExample using the logger\nconst logThat = (...params: any) => {\nconsole.log('logThat', ...params);\nconst paramString = [...params].reduce((acc, p) => {\nacc += ` ${typeof p === 'object' ? JSON.stringify(p) : p}`;\nreturn acc;\n});\nconst newLog = `${new Date().toISOString()} - ${paramString}`;\nsetLogs((prevLogs) => [...prevLogs, newLog]);\n};\n\nconst fdc3Session = await createAgent(\n'https://dev.connectictifi-interop.com',\n'myApp@myDirectory',\n{logger: logThat}\n);\n//then use the standard FDC3 API...\nExample setting a custom logo\nconst fdc3Session = await createAgent(\n'https://dev.connectictifi-interop.com',\n'myApp@myDirectory',\n{\nprops: {\nlogoSrc: 'https://mylogo.png',\n},\n}\n);\n//then use the standard FDC3 API...\nnote: If you are setting a custom logo, you'll get best results if the logo is:\nover HTTPS\nsquare\npng format\nwhite/light on a transparent background\nintegrating with existing FDC3 patterns\nBy scoping of the FDC3 API, the Connectifi Agent provides a superset of typical FDC3 functionality. Supporting the FDC3 global pattern used in Desktop Containers is simple to do as well.\n\nmaking a fdc3 global object\nconst fdc3Global = async () => {\n//create the agent and assign to the window\nwindow.fdc3 = await createAgent(\n'https://dev.connectifi-interop.com',\n'myApp@myDirectory'\n);\n\n//fire the fdc3Ready event\ndocument.dispatchEvent(new CustomEvent('fdc3Ready', {}));\n};\nintegrating into a preload\nUsing the above code, it is simple to then package the global declaration as a preload script in any Electronjs-based project.bridging with an existing fdc3 global instance\nWhen setting the bridgeGlobal configuration flag to true, the agent will bridge with the globally declared FDC3 object in it's environment. Bridging behavior will:\nif a Connectifi system/user channel is joined or left, the bridge will join or leave the global system/user channel of the same id (if it exists)\nif a context is received over the currently joined channel, the bridge will perform an fdc3.broadcast on the global with the same context\nif raiseIntent or raiseIntentForContext is called on the Connectifi scope, the Agent will also get the relevant intents from the FDC3 global environment and display them in the resolver as 'local' intents.\nnote: this feature is a work in progress and the nuance of the behavior will continue to evolve along with support for bridging in different FDC3 environments.\n\nThe Connectifi Agent can be fully customized using the configuration object passed into the constructor. The AgentConfig interface:\nexport interface AgentConfig {\nprops?: FabProps;\nheadless?: boolean;\nlogLevel?: LogLevel;\nbridgeGlobal?: boolean;\nlogger?: (...params: any) => void;\n\nonFDC3Ready?: (fdc3: DesktopAgent) => void;\nonSessionStarted?: (directory: DirectoryProps, username?: string) => void;\nonSessionError?: (errorMessage: string) => void;\nonSessionAuthRequired?: (directory: DirectoryProps) => void;\nonSignedIn?: (username: string) => void;\nonSignedOut?: () => void;\nonChannelJoined?: (channelId: string) => void;\nonChannelLeft?: () => void;\nonConnected?: (initialConnect: boolean) => void;\nonDisconnected?: (nextConnect?: number) => void;\nonWorkingChanged?: (workInProgress: boolean) => void;\nhandleIntentResolution?: (\nmessage: IntentResolutionMessage,\ncallback: ResolveCallback,\ncloseCallback: CloseCallback,\n) => void;\nhandleOpen?: (message: ConnectifiOpenMessage) => void;\n}\nprops\nThese are UI-specific properties that configure the default ‘FAB’ UX provided by the Agent (see UI Props below)\nheadlessIf set to true - no default UI is rendered by the agent.\nlogLevel\nlogging can be set to ‘debug’, ‘info’, or ‘silent’\nbridgeGlobalExperimental feature: if set to true - the Agent will attach to the window.fdc3 object (e.g. if running in a desktop container) and join to it for intents resolution and broadcast of context.\nlogger\nSpecify a custom function to output log statements.","ui-props#UI Props":"logoSrc?: string;\nposition?: ValidPositions;\nloginStyle?: LoginStyles;\nlogoSrc - defines a custom location for the logo shown in the FAB\nposition - 'tl', 'ml', 'bl', 'tr', 'mr', or 'br’. Positions the FAB in top, bottom, middle, and right/left/center of the screen.","ui-callbacks#UI Callbacks":"logger?: (...params: any) => void;\n\nonFDC3Ready?: (fdc3: DesktopAgent) => void;\nonSessionStarted?: (directory: DirectoryProps, username?: string) => void;\nonSessionError?: (errorMessage: string) => void;\nonSessionAuthRequired?: (directory: DirectoryProps) => void;\nonSignedIn?: (username: string) => void;\nonSignedOut?: () => void;\nonChannelJoined?: (channelId: string) => void;\nonChannelLeft?: () => void;\nonConnected?: (initialConnect: boolean) => void;\nonDisconnected?: (nextConnect?: number) => void;\nonWorkingChanged?: (workInProgress: boolean) => void;\nhandleIntentResolution?: (\nmessage: IntentResolutionMessage,\ncallback: ResolveCallback,\ncloseCallback: CloseCallback,\n) => void;\nhandleOpen?: (message: ConnectifiOpenMessage) => void;","handleintentresolution#handleIntentResolution":"This is called when an ambiguous list of intent results is pushed to the app for the end user to resolve. The callback will be provided with an IntentResolutionMessage data structure, along with a call back (ResolveCallback) to call when a user has selected on an app to resolve the intent with.\nexport interface IntentResolutionMessage {\nresolutionType: ResolutionType;\ncontext: Context;\ndata: AppIntentResult | AppIntentResult[];\nbridgeData?: AppIntent | AppIntent[];\n}\nThe intent resolution message has the following properties:\nresolutionType - ‘intent-resolver’ or\n‘context-resolver’ depending on if the resolution is coming from a raiseIntent or raiseIntentsForContext call.\ncontext - the FDC3 context object associated with the intent\ndata - either a single result (’intent-resolver’ type) or a list of results (’context-resolver’). See AppIntentResult below.\nbridgeData - an optional set of results coming from the bridged fdc3 global context (Desktop Agent) if the bridgeGlobal property is set to true. See AppIntentResult below.","appintentresult#AppIntentResult":"export interface AppIntentResult {\nintent: IntentMetadata;\napps: Array<ConnectifiAppMetadata>;\n}\nexport interface ConnectifiAppMetadata extends AppMetadata {\ntype: IntentResultType;\nid: string;\nurl: string;\ninstanceTitle: string;\nintents: Array<ConnectifiAppIntent>;\nproximity: number;\nuseragent: string;\nbrowser?: string;\ndevice?: string;\nos?: string;\nlastUpdate: number;\n}\nThe AppIntentResult joins up the standard FDC3 IntentMetadata type with an Array of ConnectifiAppMetadata types. (i.e. an intent and the app results matching it). The ConnectifiAppMetadata type is an extension of the standard FDC3 AppMetadata type that provides some additional properties that be used to help the user disambiguate between applications. For example:\nproximity - Starting with 0 - a number indicating the relative device and application proximity from the app that initiated the resolver. For example, if the target app is on the same device and running in the same application (e.g. Chrome) as the initiator, proximity is 0. The scoring is meant to aid sorting the list in order of apps closest to furthers from where the user is currently working.\nbrowser - indicator of browser type the app is running in\ndevice - indicator of the device the app is running on\nos - indicator of the OS the app is running on\nuseragent - the raw user agent string for the app\nonChannelJoined\nCalled when a channel is joined. Argument is the id of the channel joined.","onchannelleft#onChannelLeft":"Called when leaveCurrentChannel is executed. I.e. the user leaves the current channel but does not join another.","handleopen#handleOpen":"Called after fdc3.open or an intent is resolved. In this case, the service sends a message to the client requesting it to launch a specific app. The message format is as follows:\nexport interface ConnectifiOpenMessage {\nname?: string;\nurl?: string;\npendingId: string;\n}\nWhere name is the name of the app in the directory, url is the url to launch (for web applications), and pendingId is a nonce that will allow the newly launched app to retrieve any expected intent/context data. Note: name and url are optional depending on the type of app being launched.A typical handleOpen looks like this:\nconst handleOpen = (message : ConnectifiOpenMessage ) => {\nif (data.url && data.pendingId) {\nwindow.open(data.url, data.pendingId as string);\n}\n}\nNote the convention here of using the pendingId as the name for the new window - this is a convention picked up by the Agent - which will automatically use the name of the window to retrieve pending state for the new application. Other patterns can and will be used for non-browser clients. Also note, for most browsers, the window.open call must be sufficiently proximate to a end-user click to work. So, if you are building workflows that don’t have an opportunity for the end user to click on something before an app is launched - you will need to build some mechanism into the flow for browser (presenting the user with the link, etc).","onworkingchanged#onWorkingChanged":"Called when the agent starts or stops \"working\" or \"being busy\". the boolean argument is the current state.","onsignedin#onSignedIn":"Called after the user has successfully signed into the directory. Will be passed the username / identifier as an argument.","onsignedout#onSignedOut":"Called after the user is signed out.","onconnected#onConnected":"Called when a socket connection is established.","ondisconnected#onDisconnected":"Called when the socket connection is dropped. Will be passed the auto-reconnect time (in milliseconds) as an argument.","onsessionstarted#onSessionStarted":"Called when the connectifi agent has established a session to the service and directory.","onsessionerror#onSessionError":"Called when the connectifi agent can not establish a session to the service and directory. The error message will indicate which. This is a fatal error.","onsessionauthrequired#onSessionAuthRequired":"Called when the user could not connect to the directory because they could not be authenticated. Passed the directory name as an argument.","onautherror#onAuthError":"Called when the user could not connect to the directory because they could not be authenticated. Passed the directory name as an argument.","handling-connection-state#Handling Connection State":"Connectifi is designed to run anywhere including mobile devices where connection drop out is a common occurrence. The Agent provides a number of tools to mitigate potential connection issues.","auto-reconnect#Auto-reconnect":"If a connection is dropped, the agent will automatically manage reconnecting. Toast in the default UI will also advise end users of connection state and any reconnect attempts.","connection-errors#Connection Errors":"With FDC3 2.0, all FDC3 APIs are async. With Connectifi, any API call where a connection is rejected with an error of type ConnectionError.NoConnectionAvailable. This error can be handled and used to trigger a notification to the user, logging, and/or queueing of critical events.","onconnect--ondisconnect-callbacks#onConnect / onDisconnect callbacks":"These callbacks outlined above can be used to create custom UX around connection state. NOTE: these are not provided to manage reconnect logic as the agent itself takes care of thatThe agent provides full code isolation and its own secure connection back to its service endpoint. The directory an agent connects to controls the security profile of the interop. There are 3 basic security levels:\nOpen - any app can connect to the end point - this is recommended for development only.\nApp - an app's identity has to be validated and registered to the directory to connect.\nStrict - an app's identity must be valid and belong to the directory and the user must be authenticated to connect.\n\nThis model allows for robust security where counterparties engaged in interop are not vulnerable to spoofing, cross-site-scripting attacks, and data leakage from unauthorized apps gaining access to a desktop bus.","troubleshooting#Troubleshooting":"Connectifi is fully of the web, so all the same tools and methods you'd use to troubleshoot a webapp apply for the agent. The logger callback can also provide more flexibility for inspecting and diagnosing any issues on the client. Some baseline items to check if you are having issues with the agent are:\nHave you checked that the URL to the interop service correct?\nDo you have the correct (case-sensitive) and fully\nqualified appName@directoryName identifier for the directory you are connecting to?\nIs your app registered with the directory and does the registered origin match the origin you are connecting from? Are you using the FDC3 2.0 API in your app?\n\nFind the Connectifi NPM Module, on NPM"}},"/about":{"title":"About","data":{"":"This is the about page! This page is shown on the navbar."}},"/Use Cases/FDC3":{"title":"FDC3 Connectifi Sandbox","data":{"":"FDC3 is an open standard for applications on financial desktop to interoperate and exchange data with each other. Users benefit from a more joined-up experience, which reduces the \"friction\" in getting tasks done. Applications can launch each other, respond to activity in other apps and request functionality from each other.FDC3 is a framework, which can be easily leveraged within Connectifi. The advantage of using Connectifi, is that Connectifi works across web, desktop and mobile applications, so you are no longer limited to building all of your applications in a single framework.","adding-fdc3-to-your-application#Adding FDC3 to Your Application":"This article goes over how to add FDC3 to your application. Please note that you should already have created your directory and established your intents, apps, and contexts (as covered in our getting started article). FDC3 standardizes nouns (contexts) and verbs (intents) that apps can leverage to establish functionality and share data. Apps can both send and receive FDC3 data and events. For the most part, connecting your applications with FDC3 is identifying where you application fits in this flow of data. With FDC3, there are two types of events:\nEmitting events\nConsuming events\n\nIn this article, we'll go over what both of these events are, functions that are associated with both and how to implement them.","emitting-events#Emitting Events":"Emitting events are typically used when data in one application has utility elsewhere. For example, if you are displaying a contacts list in a CRM, each contact is a potential input into any number of other systems (chat, telephony, internal databases, or external services). Leveraging emitting events will allow you to pass data from the original source into a new platform. A number of FDC3 functions exists to help with this including:\nbroadcast\nraiseIntent\nraiseIntentForContext","broadcast#Broadcast":"The broadcast function allows an application to make a context (data) available to any connected application that is listening (this will be covered below). For example, if a users selects a contact in their CRM, using the broadcast function will make the details of that contact available for other connected applications to access. It is up to those connected applications to determine what they will do with the broadcasted contexts. If we continue with the example of a CRM contacts list, an example of a broadcast event would be broadcasting a specific contact's email address; a connected application, let's say an email client, might use this data to open a window to create a new email with the recipient as the contact's email.A simple way to implement the broadcast function looks like this:\n//broadcast an fdc3 context\nfdc3.broadcast({\ntype: \"fdc3.contact\",\nname: \"Jane Doe\",\nid: {\nemail: \"jane.doe@mail.com\"\n}\n});","raiseintent#raiseIntent":"The raiseIntent function defers functionality to the end user's environment. This allows the application raising the intent to create an experience where the end user can choose which connected application handles the contexts that are being shared and guide the workflow. For example, an application displaying overview data for financial instruments may want to defer the charting function for the end user to choose. The overview app would raise an intent to 'ViewChart' and the user would be presented with a number of charting applications to choose from (and the overview app doesn't have to know about any of them).To implement this, the code would like the following:\nfdc3.raiseIntent('ViewChart', {\ntype: 'fdc3.instrument',\nid: {\nticker: 'AAPL'\n}\n});\nWhen an intent is raised, if there are multiple apps that can handle the intent, the end user is presented with options in what's called an intent resolver. The default resolver UI in Connectifi looks like this:Please note that the resolver identifies instances of currently running apps that an intent can be sent to and apps from the directory that can be opened with the intent as well.","raiseintentforcontext#raiseIntentForContext":"The raiseIntentForContext function works very similarly to the raiseIntent function, but with a much broader scope. While the raiseIntent function finds all applications that are able to handle a specific intent, the raiseIntentForContext function finds all applications, grouped by intents, that utilize intents that can consume a passed context as input. Implementing the raiseIntentForContext would look something like this:\nfdc3.raiseIntentForContext({\ntype: 'fdc3.instrument',\nid: {\nticker: 'AAPL'\n}\n})\nThe intent resolver looks very similar to that for raiseIntent:","consuming-events#Consuming Events":"Now that we've covered emitting events, we need to do something with the data that's sent from them. This is where consuming events come in. Listeners are used to ingest contexts and respond to emitting events. When adding listeners to you app, you will want to consider the following:How are you generating the data that is displayed by your app? What are the data sources?\nWhat is the main function of your app? What does the app do with generated data? What is the primary intent?\nAre there additional discrete functions or modes of your? Are there secondary functions for the app? What other intents does the app leverage?In this article, we'll cover the following functions used for consuming events:\naddContextListener\naddIntentListener\nunsubscribingListeners\njoiningChannels","addcontextlistener#addContextListener":"The `addContextListener function allows you to create context listeners to pick up broadcasted data (context). Context listeners are triggered when a matching context is broadcasted from a connected app; in other words, this type of listener is driven by the type of data this is being passed. Apps are considered connected when they are joined to the same user/system channel (covered below). When configuring a context listener, a context type can be specified as a filter on which context events to pick up. If a filter is specified, all context events, regardless of type, will be sent to the listener. The listener will then utilize a callback function, which passes the broadcasted FDC3 context. Any number of listeners can be set and called when a matching context broadcast occurs. Adding a context listener looks like this:\nconst listener = await fdc3.addContextListener('fdc3.instrument', (context) => {\nconsole.log(\"got an instrument context!\", context);\n});","addintentlistener#addIntentListener":"The addIntentListener function works very similarly to the addContextListener function; however, it is driven by intents, rather than contexts. In other words, the intent listener is triggered when a specified intent is detected. When configuring an intent listener, the name of the intent the listener is looking for must be specified.An example of adding an intent listener would look like this:\nconst listener = await fdc3.addIntentListener('ViewChart', (context) => {\ndrawChart(context);\n});","unsubscribing-listeners#Unsubscribing Listeners":"While a listener's purpose is to pick up specific intents or contexts that are passed, listeners can also be turned off using the unsubscribe function. When a context or intent listener is created, a listener object is returned. The code for unsubscribing a listener is:listener.unsubscribe()There is no faster way to get up and running with Connectifi FDC3 than trying out our Sandbox! Explore app interop directly in your browser using the Connectifi service. Leverage the built in demo apps or use as a test harness to build your own apps. You can use Connectifi’s Sandbox to build and test your own applications. Use this code to make the connection:\nconst fdc3 = await createAgent(\n`https://dev.connectifi-interop.com`,\n`*@sandbox`,\n);\nnote: the '' in '@sandbox' is a convention for unregistered apps to connect to what's called an open directory. Since the sandbox directory is meant to be for development purposes only, it doesn't require registry or identity validation of the apps connecting in to it."}},"/advanced/satori":{"title":"Satori","data":{"":"Satori (悟り) is a Japanese Buddhist term for awakening, \"comprehension; understanding\"."}},"/another":{"title":"Another Page","data":{"":"let a = 1;\n\nconsole.log(a);","component#Component":"","external-component#External Component":""}},"/Receptors/RaiseIntent":{"title":"Raise an Intent Receptor","data":{"":"This scenario lets you raise a sample intent or build a custom one. Select an intent from the grid below, and the Connectifi service will provide you with a list of apps you can route the intent to. The intent can launch either a new app or be raised to an existing app if one is running."}},"/":{"title":"Using the Customization Examples","data":{"":"Connectifi is a cloud service that securely connects applications for interoperability across different technologies and devices. It is the easiest way to use the FDC3 standard and works without installs so that FDC3 can be used directly in a browser, bridging across desktop containers, and even in mobile and across devices. Integrating your app with Connectifi consists of 3 basic steps:\nAdd the Connectifi Agent module to your application\nMake a connection to a directory\nAdd FDC3 hooks into your application\n\nLet’s go through each step in detail.Connectifi is built to work with the brand and UX of your platform. To help you get started fast, this repo is home to a collection of code examples detailing how to customize the Connectifi Agent. All the code is open source and can be found in the /examples directory. To try it out:\nclone this repo\nnpm install\nnpm run dev\ngo to http://localhost:9090/examples/index.html for a list of all examples\n\nGot a use case you don't see here? Create an issue and let us know about it.note: For examples of how to use FDC3 API, the best place to start is with the Connectifi FDC3 Sandbox.","setting-up-the-agent#Setting up the Agent":"The Connectifi Agent is a small javascript module that lives in your application and is used to make and manage the connection to the Connectifi service and translate this into a standard FDC3 API for the consuming application. The module also provides some default UI which can be fully customized.The agent is available as a NPM module and can be integrated into your application through standard web toolchains.Install into your code using NPM:npm i @connectifi/agent-webor, access via CDN:https://unpkg.com/@connectifi/agent-web/dist/main.jsYou can use to following code to do this:\nimport { createAgent } from 'https://[interop-endpoint].connectifi-interop.com/agent/main.bundle.js';\nconst fdc3 = await createAgent(\n`https://[interop-endpoint].connectifi-interop.com`,\n`$[appName]@$[directoryName]`,\n);","connectifi-sandbox-directory#Connectifi Sandbox Directory":"There is no faster way to get up and running with Connectifi than trying out our Sandbox! Explore app interop directly in your browser using the Connectifi service. Leverage the built in demo apps or use as a test harness to build your own apps. You can use Connectifi’s Sandbox to build and test your own applications. Use this code to make the connection:\nconst fdc3 = await createAgent(\n`https://dev.connectifi-interop.com`,\n`*@sandbox`,\n);\nnote: the '' in '@sandbox' is a convention for unregistered apps to connect to what's called an open directory. Since the sandbox directory is meant to be for development purposes only, it doesn't require registry or identity validation of the apps connecting in to it.","notes#Notes":"Replace [interop-endpoint] with your own endpoint's value. For example, if you're connecting to our sandbox, you would use 'dev.'\nYou will need an application and direction set up so you can have values for [appName] and [directoryName]\n\nThis code will not only create the Connectifi agent, but also connects you to the appropriate directory.The Connectifi agent is also available for .NET. We support .NET Framework 4.6.2+ and .NET 7+; this was announced in February 2024 on our blog. An instance of the desktop agent can be created with the following line of code:var desktopAgent = new DesktopAgent(webView2.CoreWebView2)For more details on the .NET agent, please check out the NuGet package page here.We have an example of a .NET application, which includes a full login implementation, that can be found here: https://github.com/connectifi-co/equity-orderbookOnce your directory, contexts, intents, and apps are configured, the next step will be adding FDC3 to your application."}},"/SDK/DotNet":{"title":"DotNet SDK Installation","data":{"":"This repository provids a native .NET cliet for the Connectifi service along with a WPF wrapper and an example application.AgentWPF: WPF wrapper of the Connectifi.DesktopAgent making is the Agent easily consumable in a WPF applicationConnectifi.DesktopAgent: the core DesktopAgent APIs and mechanics of the Connectifi agent\nConnectifiWpfApp: test application for the Connectifi.DesktopAgent projectEquity Order Book: Demo WPF application using AgentWPF to connect","usage#Usage":"Set Equity Order Book as startup project.Modify the Agent interop service URL and appId in Equity Order Book/MainWindow.xaml.cs as needed. e.g.\nprivate async void Window_Loaded(object sender, RoutedEventArgs e)\n{\nvar agentControl = new DesktopAgentWPF();\n(this.Content as Grid).Children.Add(agentControl);\ndesktopAgent = await agentControl.CreateAgent([INTEROP SERVICE URL HERE], [APPID HERE]);\n\ndesktopAgent.OnHandleIntentResolution += (_, evt) =>\n{\n_resolverDialog = new AppSelectionWPF(this);\nCurrentIntent = _currentIntent;\nCurrentTicker = _currentTicker;\n_resolverDialog.ShowAppSelectionAsync(evt.HandleIntentResolution);\n};\ndesktopAgent.OnConnectifiEvent += OnConnectifiEvent;\nreturn;\n}\nNote: you will need to connect to an authenticated directory to have connection between your .NET App and another tech stack like a browser.To use with your own .NET application, fork this repo.","dependencies#Dependencies":"Json.NET\nMicrosoft WebView2\nfdc3-dotnet"}},"/Applications":{"title":"Applications","data":{"":"Applications are the app that you would like to connect to another application, to receive or send data. An application could be a website, native application, server app, or even a container application such as Electon, or similar.In order to get your application connected, you'll need to add the application into Connectifi, along with it's Actions and Receptors. Applications are organized into Directories, which can represent team permissions. This means an application needs to be in the same directory as another application in order for them to be able to connect with one another.","creating-an-application#Creating an Application":"Adding your applications to a directory allows them to leverage contexts and intents.","step-1-application-info#Step 1: Application Info":"Open the directory where the application will be located, click on the Create Application button in the top-right.\nApplication Info: Application info is basic metadata for your app such as name and description.\n\n\nApplication Name: This should be a clear unique ID of your application. If you have different versions of the application such as dev, prod, or even a version number, you can prefix or suffix your application name to ensure clarity. Application Name is not changeable in the future.\nApplication Title: This should be a clear name for your user, as it will be user-visible.\nLogo: We recommend a square transparent png logo, in either 124x124 pixels, or 256x256.","step-2-agent-sdk#Step 2: Agent SDK":"Agent SDK: Select the type of SDK you want to use in your application\n\n\nWeb: Our WebSDK, works if you are building for the browser in JS, or alternatively if you are using an Electron container or similar. A web application is an application that runs in the browser, or in Electron. It is primarily built using JS, HTML and CSS. Web applications. Our WebSDK can be installed using npm. Read more in our Web SDK Guide\nNative: We offer SDK's for both .Net applications, and iOS/Swift. Checkout our .Net and iOS guides.\nNone: Alternatively if you are building a server side application, or an API, you can get started without using an SDK.\n\n\n\n\nIntents: Add the application’s intents. All intents are global, to ensure reusability. Checkout Intents for more information on how to create these.","web-app-fields#Web App Fields":"StartURL: Specify the location of your web app in the \"Start URL\" field.Allowed Origins: Allowed Origins is optional, and is only applicable when the application is in a strict directories (See Directories for more information). This setting allows you to specify alternate URLs for your application. Uses for Allowed Origins include:\nApplications using different domains (i.e. localized URLs or)\nApplications that use a \"launch\" URL that is a different URL from which the app runs\n\n\n\nSingleton Application: The Singleton Application setting identifies an active instance of the application and continues to use the instance to resolve all intents, rather than launching another instance of the application with each raised intent. It is only used during intent resolution. If an application is marked as a singleton application, users are not provided with an option to open another instance of the application in the resolver modal.","native-app-fields#Native App Fields":"Interop URLL: Specify the location of your native app in the \"Interop URL\" field.App Secret: Add your native apps API key.","step-3-actions#Step 3: Actions":"Read more in our Actions guide","step-4-receptors#Step 4: Receptors":"Read more in our Receptors guide"}},"/advanced":{"title":"Advanced","data":{"":"This is the index page for the Advanced folder!"}}}